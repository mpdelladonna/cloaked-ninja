package project0;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Constructs a path from start to end using a depth first search strategy
 * 
 * @author Mike Della Donna
 *
 */
public class UniformCostSearch implements SearchStrategy {

	PriorityQueue<CellNode> queue;
	ArrayList<CellNode> greylist;
	ArrayList<Cell> blacklist;
	HashMap<CellNode,CellNode> parentMap;
	Logger log;
	
	public UniformCostSearch()
	{
		queue = new PriorityQueue<CellNode>();
		greylist = new ArrayList<CellNode>();
		blacklist = new ArrayList<Cell>();
		parentMap = new HashMap<CellNode, CellNode>();
		log = new Logger();
	}
	
	@Override
	public List<Cell> search(Point start, Point end, Land land)
	{
		//add the first node to the queue
		queue.add(new CellNode(land.getCell(start),0,null));
		return search2(start,end,land);
	}
	
	public List<Cell> search2(Point start, Point end, Land land)
	{
		//while queue has elements
		//if yes, 
		//pop next destination from the queue
		//is it the destination?
		//yes,
			//construct a list from it's parents
			//return that list
		//no
			//blacklist the node
			//add all the adjacent nodes not in blacklist into the priority queue with the current node as the parent
			//if the node is already in the queue, and has a lower cost, replace it's parent and cost
			
		//if no, no destination found
		return null;
	}

	@Override
	public Logger getLogger() {
		return log;
	}
	
	private double computeCost(Cell start, Cell end)
	{
		double gas = 1;
		
		if(start.elevation < end.elevation)
		{
			gas *= Math.abs(start.elevation - end.elevation);
		}
		else if(start.elevation > end.elevation)
		{
			gas /= Math.abs(end.elevation - start.elevation);
		}
		
		return end.cost + gas;
	}

}

class CellNode implements Comparable<CellNode>
{
	public CellNode(Cell cell, double cost, CellNode parent) 
	{
		this.cell = cell;
		this.cost = cost;
		this.parent = parent;
	}

	Cell cell;
	double cost;
	CellNode parent;
	
	@Override
	public int compareTo(CellNode o) {
		
		double test = this.cost - o.cost;
		
		int compare = 0;
		
		if (test > 0.0)
			compare = 1;
		
		if(test < 0.0)
			compare = -1;
		
		return compare;
	}
	
	@Override
	public boolean equals(Object obj) {
		return cell.equals(obj);
	}
	
	@Override
	public int hashCode() {
		return cell.hashCode();
	}
}
