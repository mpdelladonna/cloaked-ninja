package project0;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Constructs a path from start to end using a depth first search strategy
 * 
 * @author Mike Della Donna
 *
 */
public class UniformCostSearch implements SearchStrategy {

	PriorityQueue<CellNode> stack;
	ArrayList<CellNode> greylist;
	ArrayList<Cell> blacklist;
	HashMap<CellNode,CellNode> parentMap;
	Logger log;
	
	public UniformCostSearch()
	{
		stack = new PriorityQueue<CellNode>();
		greylist = new ArrayList<CellNode>();
		blacklist = new ArrayList<Cell>();
		parentMap = new HashMap<CellNode, CellNode>();
		log = new Logger();
	}
	
	@Override
	public List<Cell> search(Point start, Point end, Land land)
	{
		// add current cell to the greylist
		log.visitCell();
		log.log("Adding "+land.getCell(start)+" to the list of in progress cells");
		greylist.add(new CellNode(land.getCell(start),0));
		
		// check to see if you have reached the destination
		log.log("Checking to see if this is the destination");
		if(start.equals(end))
		{
			log.log("Destination reached, putting together the path");
			// if you have, use the parent map to get back to the original start
			//create a list to hold the path
			log.log("Creating a list to hold the path");
			LinkedList<Cell> path = new LinkedList<Cell>();
			//get the cell at the end
			log.log("Adding cells in reverse order, starting with the destination");
			CellNode current = new CellNode(land.getCell(start), 0);
			//push it onto the stack you're going to return
			path.addFirst(current.cell);
			//get it's parent
			current = parentMap.get(current);
			//while it has a parent, keep pushing them onto the stack
			log.log("Adding each parent in turn until we get to the start, which has no parent");
			while(current != null)
			{
				path.addFirst(current.cell);
				current = parentMap.get(current);
			}
			//return the stack as a list in the correct order
			log.log("Returning the path");
			return path;
		}
		
		// if you haven't, check to see if you can move to an adjacent cell
		log.log("Haven't reached the destination, checking the adjacent cells");
		boolean locationAvailable = false;
		List<Cell> temp = land.getAdjacentCells(start);
		for(Cell c : temp)
		{
			log.log("Checking "+c);
			//if c is unoccupied and has not been completed yet (not on the blacklist)
			if(!c.occupied && !greylist.contains(new CellNode(c,0)) && !blacklist.contains(c))
			{
				// a location is available
				locationAvailable = true;
				//is this location already in progress?
				log.log(c + " is not occupied, checking if it has already been queued for exploration");
				if(greylist.contains(new CellNode(c,0)))
				{
					log.log(c + " has already been sighted, checking if the new sighting is cheaper");
					//compute the index of the cell already in the list
					//this works because the equals method of cell node doesn't take cost into consideration
					//also hashcode does not take cost into consideration
					int index = greylist.indexOf(new CellNode(c,0));
					
					if( greylist.get(index).cost > computeCost(land.getCell(start), c))
					{
						log.log("The new sighting was cheaper, replacing old mapping with new one");
						
						//take the old cell out of the parent map
						parentMap.remove(greylist.get(index));
						//add the new one
						parentMap.put(new CellNode(c,computeCost(land.getCell(start), c)), new CellNode(land.getCell(start),0));
						
						//take the old cell out of the greylist
						greylist.remove(index);
						//add the new one
						greylist.add(new CellNode(c,computeCost(land.getCell(start), c)));
						
						
					}
					else
					{
						log.log("The new sighting wasn't cheaper");
					}
				}
				else
				{
					// explore this location later
					stack.add(new CellNode(c,computeCost(land.getCell(start), c)));
					// mark this location as being in progress
					greylist.add(new CellNode(c,computeCost(land.getCell(start), c)));
					// add start as its parent
					parentMap.put(new CellNode(c,computeCost(land.getCell(start), c)), new CellNode(land.getCell(start),0));
					log.log(c +" is a new cell, adding it to the greylist and the queue");
					log.log("It's parent will be the current cell, added to the parent map");
					log.log("Its priority for exploration is "+computeCost(land.getCell(start), c));
				}
			}
		}
		
		log.log("Checking if there were any adjacent cells");
		// can you move to an adjacent cell?
		if(locationAvailable)
		{
			// the new valid locations are at the top of the stack
			// recursive call on the top of the stack
			log.log("There was at least one adjacent cell, checking "+ stack.peek().cell +" next");
			return search(stack.remove().cell.getLocation(), end, land);
		}
		else
		{
			// move current square from the greylist to the blacklist
			log.log("There wasn't anywhere new to go, removing "+land.getCell(start) +" from the greylist and adding it to the blacklist, it's a dead end");
			greylist.remove(new CellNode(land.getCell(start),0));
			blacklist.add(land.getCell(start));
			
			log.log("Checking to see if there are any locations in the queue");
			// are there locations on the stack?
			if(stack.size() > 0)
			{
				// recursive call on the top of the stack
				log.log("There are new locations in the queue, checking "+stack.peek());
				return search(stack.remove().cell.getLocation(), end, land);
			}
			else
			{
				log.log("There aren't any more choices, couldn't find the destination");
				// return destination not found
				return null;
			}
			
		}
	}

	@Override
	public Logger getLogger() {
		return log;
	}
	
	private double computeCost(Cell start, Cell end)
	{
		double gas = 1;
		
		if(start.elevation < end.elevation)
		{
			gas *= Math.abs(start.elevation - end.elevation);
		}
		else if(start.elevation > end.elevation)
		{
			gas /= Math.abs(end.elevation - start.elevation);
		}
		
		return end.cost + gas;
	}

}

class CellNode implements Comparable<CellNode>
{
	public CellNode(Cell cell, double cost) 
	{
		this.cell = cell;
		this.cost = cost;
	}

	Cell cell;
	double cost;
	
	@Override
	public int compareTo(CellNode o) {
		
		double test = this.cost - o.cost;
		
		int compare = 0;
		
		if (test > 0.0)
			compare = 1;
		
		if(test < 0.0)
			compare = -1;
		
		return compare;
	}
	
	@Override
	public boolean equals(Object obj) {
		return cell.equals(obj);
	}
	
	@Override
	public int hashCode() {
		return cell.hashCode();
	}
}
